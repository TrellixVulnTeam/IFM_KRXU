"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoExceptionFilter = void 0;
const common_1 = require("@nestjs/common");
const exception_type_1 = require("../const/exception.type");
const i18n_enum_1 = require("../const/i18n.enum");
const kafkaService_1 = require("../queueService/kafkaService");
const post_kafka_1 = require("../queueService/post-kafka");
let MongoExceptionFilter = class MongoExceptionFilter {
    constructor(i18n, kafkaConfig, exceptionTopic) {
        this.i18n = i18n;
        this.logger = new common_1.Logger('HTTP');
        this.postKafka = new post_kafka_1.PostKafka(new kafkaService_1.KafkaService(kafkaConfig));
        this.exceptionTopic = exceptionTopic;
    }
    async catch(exception, host) {
        const ctx = host.switchToHttp();
        const request = ctx.getRequest();
        const response = ctx.getResponse();
        console.log('--------This error from MONGO EXCEPTİON FİLTER-----------');
        const exceptionMessage = exception.errmsg;
        console.log(exception);
        const errorType = exception_type_1.ExceptionType.MONGO_EXCEPTİON;
        const requestInformation = {
            timestamp: new Date(),
            user: request.user || {},
            path: request.url,
            method: request.method,
            body: request.body,
        };
        const errorResponseLog = {
            timestamp: new Date().toLocaleDateString(),
            path: request.url,
            method: request.method,
            message: exception.message,
        };
        const reqResObject = { requestInformation, errorResponseLog, errorType };
        switch (exception.code) {
            case 112:
                response.status(409).json({ code: 409, message: 'conflict' });
                break;
            case 211:
                response.status(500).json({ code: 500, message: 'Server down' });
                break;
            case 11000:
                const errorProperties = exceptionMessage.match(/\{.*\}/)[0];
                const message = await getI18nMongoErrorMessage(this.i18n, request, i18n_enum_1.I18NEnums.DUBLICATE_ERROR, errorProperties);
                const clientResponse = {
                    code: 400,
                    message,
                    errorProperties: errorProperties,
                };
                const finalExcep = {
                    reqResObject,
                    clientResponse,
                };
                try {
                    await this.postKafka.producerSendMessage(this.exceptionTopic, JSON.stringify(finalExcep));
                    this.logger.warn(`${JSON.stringify(finalExcep)}   `);
                    response.status(400).json(clientResponse);
                    break;
                }
                catch (error) {
                    console.log(error);
                }
            case 11600:
                response.status(500).json({ code: 500, message: exceptionMessage });
                break;
            default:
                response.status(500).json({ code: 500, message: exceptionMessage });
                break;
        }
    }
};
MongoExceptionFilter = __decorate([
    (0, common_1.Catch)(),
    __metadata("design:paramtypes", [Object, Object, Object])
], MongoExceptionFilter);
exports.MongoExceptionFilter = MongoExceptionFilter;
async function getI18nMongoErrorMessage(i18n, request, i18NEnum, errorProperties) {
    return await i18n.translate(i18NEnum, {
        lang: request.i18nLang,
        args: { errorProperties },
    });
}
//# sourceMappingURL=mongo.exception.js.map