"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggingInterceptor = void 0;
const common_1 = require("@nestjs/common");
const operators_1 = require("rxjs/operators");
const generate_log_object_1 = require("../func/generate.log.object");
const objectId_check_1 = require("../func/objectId.check");
const kafkaService_1 = require("../queueService/kafkaService");
const post_kafka_1 = require("../queueService/post-kafka");
class LoggingInterceptor {
    constructor(kafkaConfig, logTopic, operationsTopic) {
        this.logger = new common_1.Logger('HTTP');
        this.postKafka = new post_kafka_1.PostKafka(new kafkaService_1.KafkaService(kafkaConfig));
        this.logTopic = logTopic;
        this.operationsTopic = operationsTopic;
    }
    async intercept(context, next) {
        const ctx = context.switchToHttp();
        const request = ctx.getRequest();
        const response = ctx.getResponse();
        const query = request.params;
        const user = request.user;
        const method = request.method;
        const now = Date.now();
        const url = request.url;
        const parsedUrl = url.match(/^\/[^\?\/]*/)[0];
        const requestInformation = (0, generate_log_object_1.createReqLogObj)(request);
        response.on('close', async () => {
            const { statusCode, statusMessage } = response;
            const responseInformation = {
                statusCode,
                statusMessage,
                responseTime: `${Date.now() - now} ms`,
            };
            const log = { requestInformation, responseInformation };
            try {
                await this.postKafka.producerSendMessage(this.logTopic, JSON.stringify(log));
                console.log(`${this.logTopic} topic send succesful`);
            }
            catch (error) {
                console.log(`${this.logTopic} topic cannot connected due to ` + error);
            }
            this.logger.log(`${JSON.stringify(log)}   `);
        });
        if (query._id) {
            (0, objectId_check_1.checkObjectIddÄ°sValid)(query._id);
        }
        return next.handle().pipe((0, operators_1.tap)(async (responseBody) => {
            try {
                const finalResponse = { responseBody, user, requestInformation };
                if (method !== 'GET') {
                    await this.postKafka.producerSendMessage(this.operationsTopic, JSON.stringify(finalResponse), parsedUrl);
                    console.log(`${this.operationsTopic} topic send succesful`);
                }
            }
            catch (error) {
                console.log(`${this.operationsTopic} topic cannot connected due to ` + error);
            }
        }));
    }
}
exports.LoggingInterceptor = LoggingInterceptor;
//# sourceMappingURL=logger.interceptor.js.map